<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>StenoGraphs </title>
<style>
/* --- Base / Ribbon ---*/
body {
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen, Ubuntu, Cantarell, "Open Sans", "Helvetica Neue", sans-serif;
  margin: 0;
  padding: 0;
  background-color: #f3f3f3;
  color: #333;
}
.ribbon-menu {
  background-color: #fff;
  border-bottom: 1px solid #e0e0e0;
  box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
  padding: 5px 15px;
  position: sticky;
  top: 0;
  z-index: 100;
}
.tabs-container {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 5px 0;
  border-bottom: 1px solid #e0e0e0;
}
.tabs {
  display: flex;
}
.tab-button {
  background-color: transparent;
  border: none;
  padding: 10px 15px;
  font-size: 15px;
  cursor: pointer;
  border-bottom: 2px solid transparent;
  transition: all 0.2s ease;
  color: #555;
  font-weight: 500;
}
.tab-button:hover {
  background-color: #f0f0f0;
}
.tab-button.active {
  border-color: #0078d7;
  color: #0078d7;
}
.tell-me {
  display: flex;
  align-items: center;
}
.tell-me input {
  padding: 8px 12px;
  border: 1px solid #ccc;
  border-radius: 4px;
  font-size: 14px;
  width: 250px;
  transition: all 0.2s;
}
.tell-me input:focus {
  outline: none;
  border-color: #0078d7;
  box-shadow: 0 0 0 2px rgba(0, 120, 215, 0.2);
}
.tab-panel {
  display: none;
  padding: 10px 0;
  margin-top: 5px;
}
.tab-panel.active {
  display: flex;
  flex-wrap: wrap;
  gap: 15px;
  align-items: flex-start;
}
.ribbon-group {
  padding: 0 15px;
  border-right: 1px solid #e0e0e0;
  display: flex;
  flex-direction: column;
  gap: 5px;
  align-items: center;
}
.ribbon-group:last-child {
  border-right: none;
}
.ribbon-group-title {
  font-size: 11px;
  color: #888;
  text-align: center;
  margin-top: 5px;
}
.ribbon-group-items {
  display: flex;
  gap: 5px;
  flex-wrap: wrap;
}
.ribbon-item {
  padding: 8px 10px;
  border: 1px solid #ddd;
  border-radius: 4px;
  cursor: pointer;
  background-color: #f9f9f9;
  font-size: 14px;
  transition: background-color 0.2s, transform 0.1s;
  display: flex;
  align-items: center;
  justify-content: center;
  min-width: 30px;
}
.ribbon-item:hover {
  background-color: #e9e9e9;
}
.ribbon-item:active {
  transform: scale(0.98);
}
.ribbon-item.active {
  background-color: #d1e2f6;
  border-color: #0078d7;
}
.document-container {
  padding: 20px;
  display: flex;
  justify-content: center;
  min-height: calc(100vh - 100px);
}
#editor {
  width: 8.5in;
  min-height: 11in;
  padding: 1in;
  background-color: white;
  border: 1px solid #ccc;
  box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
  outline: none;
  line-height: 1.6;
  font-size: 16px;
  word-wrap: break-word;
  white-space: pre-wrap;
  position: relative;
}
#drawing-canvas {
  position: absolute;
  top: 0;
  left: 0;
  z-index: 10;
  pointer-events: none;
}
.drawing-canvas-active {
  cursor: crosshair;
  pointer-events: auto !important;
}
.spellcheck-highlight {
  background-color: #fce8e8;
  border-bottom: 2px solid #ff4d4d;
}
.theme-select {
  padding: 8px 10px;
  border: 1px solid #ddd;
  border-radius: 4px;
}

/* --- App-specific layout --- */
#editor {
  padding-top: 0.6in;
}
.editor-topbar {
  display: flex;
  gap: 10px;
  align-items: center;
  padding: 10px 0;
}
#chart-canvas {
  width: 100%;
  max-width: 100%;
  height: 480px;
}
.controls {
  display: grid;
  grid-template-columns: 1.4fr 1fr;
  gap: 16px;
  width: 100%;
  margin-top: 12px;
}
.panel {
  background: #fafafa;
  border: 1px solid #e6e6e6;
  border-radius: 6px;
  padding: 10px;
}
.panel-title {
  font-size: 13px;
  color: #666;
  margin-bottom: 8px;
}
label.small {
  font-size: 12px;
  color: #666;
}
.input, textarea, select {
  width: 100%;
  box-sizing: border-box;
}
.textarea {
  width: 100%;
  min-height: 150px;
  border: 1px solid #ddd;
  border-radius: 4px;
  padding: 8px;
  font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, "Courier New", monospace;
  font-size: 13px;
  background: #fff;
  color: #333;
}
.row {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 8px;
}
.btn {
  background: #f9f9f9;
  border: 1px solid #ddd;
  border-radius: 4px;
  padding: 8px 10px;
  font-size: 14px;
  cursor: pointer;
}
.btn:hover { background: #efefef; }
.btn.primary {
  background: #0078d7;
  border-color: #0078d7;
  color: #fff;
}
.badge {
  display: inline-block;
  padding: 2px 6px;
  border-radius: 10px;
  font-size: 11px;
  background: #eef5ff;
  color: #2a6ad7;
}
.flex { display: flex; gap: 8px; align-items: center; flex-wrap: wrap; }
.hidden { display: none !important; }
.kv {
  display: grid;
  grid-template-columns: 1.2fr 1fr;
  gap: 8px;
  align-items: center;
}
.color-input { width: 36px; height: 28px; padding: 0; border: 1px solid #ddd; border-radius: 4px; }
footer.note {
  margin-top: 10px; font-size: 12px; color: #777;
}
</style>
</head>
<body>
  <div class="ribbon-menu">
    <div class="tabs-container">
      <div class="tabs">
        <button class="tab-button active" data-tab="insert">Insert</button>
        <button class="tab-button" data-tab="data">Data</button>
        <button class="tab-button" data-tab="style">Style</button>
        <button class="tab-button" data-tab="export">Export</button>
      </div>
      <div class="tell-me">
        <input id="commandBox" type="text" placeholder="Type: 'line sales by month', 'histogram 20 bins', 'waterfall cashflow'..." />
      </div>
    </div>
<!-- This is the main section! -->
    <div id="insert" class="tab-panel active">
      <div class="ribbon-group">
        <div class="ribbon-group-items">
          <button class="ribbon-item chart-type" data-type="bar">Bar</button>
          <button class="ribbon-item chart-type" data-type="column">Column</button>
          <button class="ribbon-item chart-type" data-type="line">Line</button>
          <button class="ribbon-item chart-type" data-type="area">Area</button>
          <button class="ribbon-item chart-type" data-type="pie">Pie</button>
          <button class="ribbon-item chart-type" data-type="histogram">Histogram</button>
          <button class="ribbon-item chart-type" data-type="scatter">Scatter</button>
          <button class="ribbon-item chart-type" data-type="radar">Radar</button>
          <button class="ribbon-item chart-type" data-type="bubble">Bubble</button>
          <button class="ribbon-item chart-type" data-type="waterfall">Waterfall</button>
        </div>
        <div class="ribbon-group-title">Chart types</div>
      </div>

      <div class="ribbon-group">
        <div class="ribbon-group-items">
          <button class="ribbon-item" id="btnSample">Sample data</button>
          <button class="ribbon-item" id="btnClear">Clear</button>
          <button class="ribbon-item" id="btnUpdate">Update</button>
        </div>
        <div class="ribbon-group-title">Quick actions</div>
      </div>

      <div class="ribbon-group">
        <div class="ribbon-group-items">
          <label class="small">Title</label>
          <input id="chartTitle" class="input" placeholder="Chart title" />
          <label class="small">Legend</label>
          <select id="legendPos" class="input">
            <option value="top">Top</option>
            <option value="bottom">Bottom</option>
            <option value="left">Left</option>
            <option value="right">Right</option>
            <option value="hidden">Hidden</option>
          </select>
        </div>
        <div class="ribbon-group-title">Meta</div>
      </div>
    </div>

    <div id="data" class="tab-panel">
      <div class="ribbon-group">
        <div class="ribbon-group-items">
          <button class="ribbon-item" id="modeJSON">JSON</button>
          <button class="ribbon-item" id="modeCSV">CSV</button>
        </div>
        <div class="ribbon-group-title">Mode</div>
      </div>
      <div class="ribbon-group">
        <div class="ribbon-group-items">
          <button class="ribbon-item" id="btnAddSeries">Add series</button>
          <button class="ribbon-item" id="btnRemoveSeries">Remove series</button>
        </div>
        <div class="ribbon-group-title">Series</div>
      </div>
      <div class="ribbon-group">
        <div class="ribbon-group-items">
          <label class="small">Histogram bins</label>
          <input id="histBins" type="number" class="input" min="2" max="100" value="10" />
          <label class="small">Smooth lines</label>
          <select id="smoothness" class="input">
            <option value="0">0</option>
            <option value="0.2">0.2</option>
            <option value="0.4">0.4</option>
            <option value="0.6">0.6</option>
            <option value="0.8">0.8</option>
          </select>
          <label class="small">Stacked</label>
          <select id="stacked" class="input">
            <option value="false">No</option>
            <option value="true">Yes</option>
          </select>
        </div>
        <div class="ribbon-group-title">Analysis</div>
      </div>
    </div>

    <div id="style" class="tab-panel">
      <div class="ribbon-group">
        <div class="ribbon-group-items">
          <label class="small">Palette</label>
          <select id="palette" class="input">
            <option value="classic">Classic</option>
            <option value="pastel">Pastel</option>
            <option value="vivid">Vivid</option>
            <option value="mono">Mono blue</option>
          </select>
          <label class="small">Background</label>
          <input id="bgColor" class="color-input" type="color" value="#ffffff" />
          <label class="small">Grid lines</label>
          <select id="gridLines" class="input">
            <option value="true">Show</option>
            <option value="false">Hide</option>
          </select>
        </div>
        <div class="ribbon-group-title">Appearance</div>
      </div>
    </div>

    <div id="export" class="tab-panel">
      <div class="ribbon-group">
        <div class="ribbon-group-items">
          <button class="ribbon-item" id="btnExportPNG">Export PNG</button>
          <button class="ribbon-item" id="btnCopyConfig">Copy config</button>
        </div>
        <div class="ribbon-group-title">Output</div>
      </div>
    </div>
  </div>

  <div class="document-container">
    <div id="editor">
      <div class="editor-topbar">
        <span class="badge" id="chartTypeBadge">Type: line</span>
        <span class="badge" id="dataModeBadge">Data: JSON</span>
        <button class="btn primary" id="btnRender">Render</button>
      </div>
      <canvas id="chart-canvas" aria-label="Chart canvas"></canvas>

      <div class="controls">
        <div class="panel">
          <div class="panel-title">Data input</div>
          <textarea id="dataInput" class="textarea" spellcheck="false"></textarea>
          <footer class="note">
            JSON: { "labels": [...], "datasets": [{ "label": "...", "data": [...] }]}<br/>
            CSV (bar/line/area/column): first row headers; first column labels.<br/>
            CSV (scatter): columns x,y,label; CSV (bubble): x,y,r,label.
          </footer>
        </div>

        <div class="panel">
          <div class="panel-title">Options</div>
          <div class="kv"><label class="small">X axis title</label><input id="xTitle" class="input" placeholder="X axis" /></div>
          <div class="kv"><label class="small">Y axis title</label><input id="yTitle" class="input" placeholder="Y axis" /></div>
          <div class="kv"><label class="small">Min Y</label><input id="yMin" class="input" type="number" placeholder="auto" /></div>
          <div class="kv"><label class="small">Max Y</label><input id="yMax" class="input" type="number" placeholder="auto" /></div>
          <div class="kv"><label class="small">Show values</label>
            <select id="showValues" class="input">
              <option value="false">No</option>
              <option value="true">Yes</option>
            </select>
          </div>
          <div class="kv"><label class="small">Animation</label>
            <select id="anim" class="input">
              <option value="true">On</option>
              <option value="false">Off</option>
            </select>
          </div>
          <div class="kv"><label class="small">Tooltips</label>
            <select id="tooltips" class="input">
              <option value="true">Show</option>
              <option value="false">Hide</option>
            </select>
          </div>
          <div class="kv"><label class="small">Aspect ratio</label>
            <select id="aspect" class="input">
              <option value="auto">Auto</option>
              <option value="16/9">16:9</option>
              <option value="4/3">4:3</option>
              <option value="1">Square</option>
            </select>
          </div>
        </div>
      </div>

    </div>
  </div>

<!-- Chart.js -->
<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.3/dist/chart.umd.min.js"></script>

<script>
/* ---------------------------------------
   StenoGraphs — Stable JS (drop-in)
   Works with existing HTML IDs and layout.
---------------------------------------- */

// Tiny DOM helpers
const $ = (s, root = document) => root.querySelector(s);
const $$ = (s, root = document) => Array.from(root.querySelectorAll(s));

// Global state
const State = {
  chart: null,
  currentType: 'line',
  dataMode: 'json',
  paletteName: 'classic',
  renderScheduled: false,
  debounceTimer: null,
  lastConfig: null
};

// Palettes
const palettes = {
  classic: ['#2a6ad7','#ff7f0e','#2ca02c','#d62728','#9467bd','#8c564b','#e377c2','#7f7f7f','#bcbd22','#17becf'],
  pastel:  ['#80b1d3','#fdb462','#b3de69','#fb8072','#cab2d6','#fccde5','#ccebc5','#d9d9d9','#ffe082','#a6cee3'],
  vivid:   ['#1f77b4','#ff4136','#2ecc40','#ff851b','#b10dc9','#0074d9','#ffdc00','#39cccc','#01ff70','#85144b'],
  mono:    ['#0078d7','#0d6efd','#1e88e5','#2196f3','#42a5f5','#64b5f6','#90caf9','#bbdefb','#e3f2fd','#0a58ca']
};

// Utils
function safeParseJSON(text, fallback = { labels: [], datasets: [] }) {
  try { return JSON.parse(text); } catch { return fallback; }
}
function hexToRgba(hex, a = 0.3) {
  const m = hex.replace('#', '');
  const bigint = parseInt(m, 16);
  if (Number.isNaN(bigint)) return `rgba(0,0,0,${a})`;
  const r = (bigint >> 16) & 255, g = (bigint >> 8) & 255, b = bigint & 255;
  return `rgba(${r}, ${g}, ${b}, ${a})`;
}
function currentColors(count) {
  const arr = palettes[State.paletteName] || palettes.classic;
  return !count ? arr : arr.slice(0, Math.max(1, Math.min(count, arr.length)));
}
function parseAspect(value) {
  if (!value || value === 'auto') return undefined;
  const parts = String(value).split('/');
  if (parts.length === 2) {
    const a = parseFloat(parts[0]), b = parseFloat(parts[1]);
    if (!Number.isNaN(a) && !Number.isNaN(b) && b !== 0) return a / b;
  }
  const num = parseFloat(value);
  return Number.isNaN(num) ? undefined : num;
}
function debounceRender(delay = 120) {
  clearTimeout(State.debounceTimer);
  State.debounceTimer = setTimeout(scheduleRender, delay);
}
function scheduleRender() {
  if (State.renderScheduled) return;
  State.renderScheduled = true;

  const doRender = () => {
    State.renderScheduled = false;
    renderChart();
  };

  if ('requestIdleCallback' in window) {
    requestIdleCallback(doRender, { timeout: 250 });
  } else {
    requestAnimationFrame(doRender);
  }
}

// CSV → data
function csvToData(text, type) {
  const rows = text
    .trim()
    .split(/\r?\n/)
    .map(r => r.split(',').map(c => c.trim()))
    .filter(r => r.length && r.some(cell => cell !== ''));

  if (!rows.length) return { labels: [], datasets: [] };

  if (type === 'scatter' || type === 'bubble') {
    const firstNum = parseFloat(rows[0]?.[0]);
    const hasHeader = Number.isNaN(firstNum);
    const dataRows = hasHeader ? rows.slice(1) : rows;
    const seriesMap = new Map();
    for (const r of dataRows) {
      const [xv, yv, rvOrLabel, maybeLabel] = r;
      const x = parseFloat(xv), y = parseFloat(yv);
      if (Number.isNaN(x) || Number.isNaN(y)) continue;
      const label = (hasHeader ? maybeLabel : maybeLabel || rvOrLabel) || 'Series 1';
      let point = { x, y };
      if (type === 'bubble') {
        const rv = parseFloat(rvOrLabel);
        point.r = Number.isNaN(rv) ? 6 : rv;
      }
      if (!seriesMap.has(label)) seriesMap.set(label, []);
      seriesMap.get(label).push(point);
    }
    return {
      labels: [],
      datasets: Array.from(seriesMap.entries()).map(([label, data]) => ({ label, data }))
    };
  }

  if (type === 'pie') {
    const firstVal = parseFloat(rows[0]?.[1]);
    const hasHeader = Number.isNaN(firstVal);
    const dataRows = hasHeader ? rows.slice(1) : rows;
    const labels = [], data = [];
    for (const r of dataRows) {
      const name = r[0];
      const val = parseFloat(r[1]);
      if (!name || Number.isNaN(val)) continue;
      labels.push(name); data.push(val);
    }
    return { labels, datasets: [{ label: 'Series 1', data }] };
  }

  // Bar/Column/Line/Area/Radar/Histogram
  const headers = rows[0];
  const labels = rows.slice(1).map(r => r[0]);
  const datasets = [];
  for (let c = 1; c < headers.length; c++) {
    const label = headers[c] || `Series ${c}`;
    const data = rows.slice(1).map(r => {
      const v = parseFloat(r[c]); return Number.isNaN(v) ? null : v;
    });
    datasets.push({ label, data });
  }
  return { labels, datasets };
}

function jsonToData(text) {
  const obj = safeParseJSON(text);
  const ds = Array.isArray(obj.datasets) ? obj.datasets : [];
  return {
    labels: Array.isArray(obj.labels) ? obj.labels : [],
    datasets: ds.map(d => ({
      label: d.label ?? 'Series',
      data: Array.isArray(d.data) ? d.data : [],
      backgroundColor: d.backgroundColor,
      borderColor: d.borderColor
    }))
  };
}

// Histogram and Waterfall builders
function genHistogram(input, binsCount) {
  const values = (input.datasets || [])
    .flatMap(d => d.data)
    .map(Number)
    .filter(v => Number.isFinite(v));

  if (values.length === 0) return { labels: [], datasets: [] };

  const min = Math.min(...values);
  const max = Math.max(...values);
  const bins = Math.max(2, Math.min(100, Math.floor(binsCount || 10)));
  const step = (max - min) / bins || 1;

  const edges = Array.from({ length: bins }, (_, i) => min + i * step);
  const counts = new Array(bins).fill(0);
  for (const v of values) {
    let idx = Math.floor((v - min) / step);
    if (idx >= bins) idx = bins - 1;
    if (idx < 0) idx = 0;
    counts[idx]++;
  }
  const labels = edges.map((e, i) => {
    const end = i === bins - 1 ? max : (e + step);
    return `${e.toFixed(2)}–${end.toFixed(2)}`;
  });
  return { labels, datasets: [{ label: 'Frequency', data: counts }] };
}

function genWaterfall(input) {
  const labels = Array.isArray(input.labels) ? input.labels.slice() : [];
  const raw = (input.datasets?.[0]?.data || []).map(Number);
  const startProvided = labels[0]?.toLowerCase?.().includes('start');
  const startVal = startProvided ? raw[0] : 0;
  const steps = startProvided ? raw.slice(1) : raw.slice();
  const stepLabels = startProvided ? labels.slice(1) : labels.slice();

  let running = startVal;
  const data = [], bases = [];
  for (let i = 0; i < steps.length; i++) {
    const v = steps[i];
    if (!Number.isFinite(v)) { data.push(0); bases.push(running); continue; }
    const base = v >= 0 ? running : running + v;
    bases.push(base);
    data.push(Math.abs(v));
    running += v;
  }
  stepLabels.push('Total');
  bases.push(0);
  data.push(Math.abs(running));

  const colors = stepLabels.map((_, i) => {
    if (i === stepLabels.length - 1) return '#6c757d';
    return steps[i] >= 0 ? '#2ca02c' : '#d62728';
  });

  return {
    labels: stepLabels,
    datasets: [{
      label: 'Waterfall',
      data: data.map((h, i) => ({ x: stepLabels[i], y: h, base: bases[i] })),
      backgroundColor: colors,
      borderWidth: 0
    }]
  };
}

// Data shaping
function areaizeDatasets(ds, tension = 0.2) {
  return ds.map(d => ({ ...d, fill: true, tension }));
}
function applyPalette(ds, mode) {
  const colors = currentColors(ds.length);
  return ds.map((d, i) => {
    const stroke = d.borderColor || colors[i % colors.length];
    const fill = d.backgroundColor || (mode === 'pie' ? stroke : hexToRgba(stroke, 0.25));
    return { ...d, borderColor: stroke, backgroundColor: fill };
  });
}

// Chart manager
const ChartManager = {
  create(ctx, config) {
    // Ensure previous instance is gone
    this.destroy();
    State.chart = new Chart(ctx, config);
    return State.chart;
  },
  update(config) {
    // If type or indexAxis changed, full recreate; else patch
    const prev = State.lastConfig;
    const typeChanged = !prev || prev.type !== config.type;
    const axisChanged = !prev || prev.options?.indexAxis !== config.options?.indexAxis;

    if (!State.chart || typeChanged || axisChanged) {
      return this.create($('#chart-canvas').getContext('2d'), config);
    }

    // Patch data/options to avoid recreation
    State.chart.config.data = config.data;
    State.chart.options = config.options;
    State.chart.update('none');
    return State.chart;
  },
  destroy() {
    if (State.chart && typeof State.chart.destroy === 'function') {
      State.chart.destroy();
    }
    State.chart = null;
  }
};

// Read data from UI
function readData() {
  let parsed = { labels: [], datasets: [] };
  if (State.dataMode === 'csv') {
    parsed = csvToData($('#dataInput').value || '', State.currentType);
  } else {
    parsed = jsonToData($('#dataInput').value || '{}');
  }

  if (State.currentType === 'histogram') {
    const bins = Math.max(2, Math.min(100, parseInt($('#histBins').value || '10', 10)));
    return genHistogram(parsed, bins);
  }
  if (State.currentType === 'waterfall') {
    return genWaterfall(parsed);
  }
  return parsed;
}

function buildConfig() {
  const { labels, datasets } = readData();

  const legendPos = $('#legendPos').value;
  const bg = $('#bgColor').value || '#ffffff';
  const showGrid = $('#gridLines').value === 'true';
  const smooth = parseFloat($('#smoothness').value || '0');
  const stacked = $('#stacked').value === 'true';
  const showVals = $('#showValues').value === 'true'; // kept for compatibility
  const anim = $('#anim').value === 'true';
  const tooltips = $('#tooltips').value === 'true';
  const aspect = parseAspect($('#aspect').value);
  const yMin = parseFloat($('#yMin').value);
  const yMax = parseFloat($('#yMax').value);
  const title = $('#chartTitle').value || '';

  let type = State.currentType;
  if (type === 'column') type = 'bar';
  if (type === 'area') type = 'line';
  if (type === 'histogram') type = 'bar';
  if (type === 'waterfall') type = 'bar';

  let indexAxis = 'x';
  if (State.currentType === 'bar') indexAxis = 'y';
  if (['column','histogram','waterfall'].includes(State.currentType)) indexAxis = 'x';

  // Tension and fills
  let ds = datasets.slice();
  if (State.currentType === 'area') ds = areaizeDatasets(ds, smooth);
  if (State.currentType === 'line') ds = ds.map(d => ({ ...d, tension: smooth }));

  // Palette
  const paletteKind = (State.currentType === 'pie' || State.currentType === 'radar') ? 'pie' : 'series';
  ds = applyPalette(ds, paletteKind);

  // Pie: single dataset
  if (State.currentType === 'pie') {
    const merged = {
      label: ds[0]?.label || 'Series 1',
      data: ds[0]?.data || [],
      backgroundColor: currentColors((ds[0]?.data || []).length)
    };
    ds = [merged];
  }

  // Scales
  const axisTitle = t => ({ display: !!t, text: t });
  const commonScales = {
    x: { stacked, grid: { display: showGrid }, title: axisTitle($('#xTitle').value) },
    y: {
      stacked, grid: { display: showGrid }, title: axisTitle($('#yTitle').value),
      suggestedMin: Number.isFinite(yMin) ? yMin : undefined,
      suggestedMax: Number.isFinite(yMax) ? yMax : undefined
    }
  };
  const xyScales = {
    x: { type: 'linear', grid: { display: showGrid }, title: axisTitle($('#xTitle').value) },
    y: { type: 'linear', grid: { display: showGrid }, title: axisTitle($('#yTitle').value) }
  };

  // Decimation: only for large line/area/scatter/bubble datasets
  const enableDecimation = ['line','scatter','bubble'].includes(type);

  const config = {
    type,
    data: { labels, datasets: ds },
    options: {
      parsing: true,            // allow decimation to work on standard arrays
      normalized: true,         // better performance with uniform data types
      responsive: true,
      maintainAspectRatio: Boolean(aspect),
      aspectRatio: aspect,
      animation: anim ? { duration: 300 } : false,
      backgroundColor: bg,
      plugins: {
        legend: { display: legendPos !== 'hidden', position: legendPos === 'hidden' ? 'top' : legendPos },
        tooltip: { enabled: tooltips },
        title: { display: !!title, text: title },
        decimation: enableDecimation ? { enabled: true, algorithm: 'lttb', samples: 1000 } : { enabled: false }
      },
      scales: (['pie','radar'].includes(State.currentType)) ? undefined
           : (['scatter','bubble'].includes(State.currentType)) ? xyScales
           : commonScales,
      indexAxis
    }
  };

  // Waterfall-specific tooltips
  if (State.currentType === 'waterfall') {
    config.options.plugins.tooltip = {
      enabled: true,
      callbacks: {
        label: (ctx) => {
          const raw = ctx.raw || {};
          const base = raw.base ?? 0;
          const delta = raw.y ?? 0;
          const end = base + delta;
          if (ctx.dataIndex === (labels.length - 1)) return `Total: ${end}`;
          return `Δ ${delta} (from ${base} to ${end})`;
        }
      }
    };
  }

  // Lighten bar borders to reduce overdraw
  if (type === 'bar') {
    config.data.datasets.forEach(d => {
      d.borderWidth = 0.5;
      d.borderColor = hexToRgba(d.borderColor || '#000000', 0.35);
    });
  }

  // Canvas bg color (CSS)
  $('#chart-canvas').style.background = bg;

  // Value labels overlay is disabled by default to avoid extra canvas passes
  // If you really want it, you can re-enable after update via attachValueLabels(State.chart)

  return config;
}

// Rendering
function renderChart() {
  const ctx = $('#chart-canvas').getContext('2d', { willReadFrequently: false });
  const cfg = buildConfig();

  // If config is deeply identical, skip update (cheap check)
  const cfgStr = JSON.stringify(cfg, (k, v) => (typeof v === 'function' ? undefined : v));
  const lastStr = State.lastConfig ? JSON.stringify(State.lastConfig, (k, v) => (typeof v === 'function' ? undefined : v)) : '';
  State.lastConfig = cfg;

  if (cfgStr === lastStr && State.chart) {
    // No material change
    return;
  }

  ChartManager.update(cfg);
}

// Value labels (optional; disabled by default to save memory/draws)
function attachValueLabels(chart) {
  if (!chart) return;
  const ctx = chart.ctx;
  chart.draw();
  ctx.save();
  ctx.font = '12px system-ui';
  ctx.fillStyle = '#333';
  const metas = chart.data.datasets.map((_, i) => chart.getDatasetMeta(i));

  metas.forEach((meta, di) => {
    if (!meta || !meta.data) return;
    meta.data.forEach((el, i) => {
      const val = chart.data.datasets[di].data[i];
      if (!el || el.x == null || el.y == null) return;
      let text = '';
      if (typeof val === 'number') text = String(val);
      else if (val && typeof val === 'object') {
        if ('r' in val) text = `${val.x}, ${val.y} (r=${val.r})`;
        else if ('base' in val) text = `${(val.base ?? 0) + (val.y ?? 0)}`;
        else text = `${val.x}, ${val.y}`;
      }
      ctx.textAlign = 'center';
      ctx.fillText(text, el.x, el.y - 6);
    });
  });
  ctx.restore();
}

// UI wiring (single-bind; no duplicate listeners)
function initUI() {
  // Tabs
  $$('.tab-button').forEach(btn => {
    btn.addEventListener('click', () => {
      $$('.tab-button').forEach(b => b.classList.remove('active'));
      btn.classList.add('active');
      const id = btn.dataset.tab;
      $$('.tab-panel').forEach(p => p.classList.remove('active'));
      $('#' + id).classList.add('active');
    }, { passive: true });
  });

  // Chart type buttons
  $$('.chart-type').forEach(btn => {
    btn.addEventListener('click', () => {
      $$('.chart-type').forEach(b => b.classList.remove('active'));
      btn.classList.add('active');
      setChartType(btn.dataset.type);
      debounceRender(80);
    }, { passive: true });
  });

  // Data mode
  $('#modeJSON').addEventListener('click', () => { setDataMode('json'); debounceRender(); }, { passive: true });
  $('#modeCSV').addEventListener('click', () => { setDataMode('csv'); debounceRender(); }, { passive: true });

  // Quick actions
  $('#btnSample').addEventListener('click', () => { loadSample(); debounceRender(60); });
  $('#btnClear').addEventListener('click', () => { $('#dataInput').value = ''; debounceRender(); });
  $('#btnAddSeries').addEventListener('click', () => { addSeries(); debounceRender(); });
  $('#btnRemoveSeries').addEventListener('click', () => { removeSeries(); debounceRender(); });
  $('#btnRender').addEventListener('click', () => scheduleRender());
  $('#btnUpdate').addEventListener('click', () => scheduleRender());

  // Style/Options
  $('#palette').addEventListener('change', e => { State.paletteName = e.target.value; debounceRender(); });
  ['legendPos','chartTitle','gridLines','bgColor','smoothness','stacked','histBins',
   'yMin','yMax','xTitle','yTitle','anim','tooltips','aspect','showValues'
  ].forEach(id => {
    const el = $('#' + id);
    if (!el) return;
    const evt = el.tagName === 'INPUT' || el.tagName === 'TEXTAREA' ? 'input' : 'change';
    el.addEventListener(evt, () => debounceRender(120));
  });

  // Export
  $('#btnExportPNG').addEventListener('click', () => {
    try {
      const a = document.createElement('a');
      a.download = `stenographs-${State.currentType}.png`;
      a.href = $('#chart-canvas').toDataURL('image/png', 1.0);
      a.click();
    } catch {}
  });
  $('#btnCopyConfig').addEventListener('click', () => {
    const cfg = buildConfig();
    navigator.clipboard.writeText(JSON.stringify(cfg, null, 2)).catch(() => {});
  });

  // Command box
  $('#commandBox').addEventListener('keydown', e => {
    if (e.key !== 'Enter') return;
    const v = e.target.value.trim().toLowerCase();
    const type = ['bar','column','line','area','pie','histogram','scatter','radar','bubble','waterfall'].find(t => v.includes(t));
    if (type) setChartType(type);
    const m = v.match(/(\d+)\s*bin/);
    if (m) $('#histBins').value = m[1];
    debounceRender(50);
  }, { passive: true });
}

function setChartType(type) {
  State.currentType = type;
  $('#chartTypeBadge').textContent = `Type: ${type}`;
  // Show/hide axis-related controls
  const hideFor = ['pie','radar'];
  const axisNeeded = !hideFor.includes(type);
  ['xTitle','yTitle','yMin','yMax','stacked','smoothness'].forEach(id => {
    const node = $('#' + id);
    if (!node) return;
    const group = node.closest('.kv') || node;
    group.classList.toggle('hidden', !axisNeeded && ['yMin','yMax','stacked','smoothness','xTitle','yTitle'].includes(id));
  });
}

function setDataMode(mode) {
  State.dataMode = mode;
  $('#dataModeBadge').textContent = `Data: ${mode.toUpperCase()}`;
}

// Samples
function loadSample() {
  const samples = {
    line: {
      labels: ['Jan','Feb','Mar','Apr','May','Jun','Jul'],
      datasets: [
        { label: 'Revenue', data: [12, 19, 13, 25, 18, 22, 30] },
        { label: 'Cost', data: [8, 11, 9, 12, 10, 13, 15] }
      ]
    },
    area: {
      labels: ['2019','2020','2021','2022','2023'],
      datasets: [
        { label: 'iOS', data: [20,25,30,42,50] },
        { label: 'Android', data: [28,33,35,38,44] }
      ]
    },
    bar: {
      labels: ['A','B','C','D','E'],
      datasets: [
        { label: 'North', data: [12,18,7,13,20] },
        { label: 'South', data: [10,15,12,9,16] }
      ]
    },
    column: {
      labels: ['Q1','Q2','Q3','Q4'],
      datasets: [{ label: 'Units', data: [120, 160, 140, 180] }]
    },
    pie: {
      labels: ['Alpha','Beta','Gamma','Delta'],
      datasets: [{ label: 'Share', data: [35, 25, 20, 20] }]
    },
    scatter: {
      labels: [],
      datasets: [
        { label: 'Set 1', data: [{x:1,y:1},{x:2,y:1.2},{x:3,y:2.5},{x:4,y:2.8}] },
        { label: 'Set 2', data: [{x:1,y:0.8},{x:2,y:1.7},{x:3,y:1.9},{x:4,y:3.1}] }
      ]
    },
    bubble: {
      labels: [],
      datasets: [
        { label: 'Markets', data: [{x:10,y:20,r:12},{x:15,y:12,r:18},{x:20,y:25,r:10}] }
      ]
    },
    radar: {
      labels: ['Speed','Reliability','Usability','Features','Security','Support'],
      datasets: [
        { label: 'Product A', data: [65,59,90,81,56,55] },
        { label: 'Product B', data: [28,48,40,19,96,27] }
      ]
    },
    histogram: {
      labels: [],
      datasets: [{ label: 'Measurements', data: [1.2,1.5,1.7,1.8,2.2,1.2,1.3,2.6,2.8,3.0,2.1,2.0,2.5,1.9] }]
    },
    waterfall: {
      labels: ['Start','Sales','COGS','Marketing','R&D','Other','Net'],
      datasets: [{ label: 'Cashflow', data: [100, 60, -30, -10, -8, -2] }]
    }
  };
  const s = samples[State.currentType] || samples.line;
  $('#dataInput').value = JSON.stringify(s, null, 2);
  setDataMode('json');
}

// Series mutators (JSON mode only)
function addSeries() {
  const obj = safeParseJSON($('#dataInput').value || '{}', { labels: [], datasets: [] });
  obj.datasets = obj.datasets || [];
  obj.datasets.push({ label: `Series ${obj.datasets.length + 1}`, data: new Array((obj.labels||[]).length).fill(0) });
  $('#dataInput').value = JSON.stringify(obj, null, 2);
}
function removeSeries() {
  const obj = safeParseJSON($('#dataInput').value || '{}', { labels: [], datasets: [] });
  obj.datasets = (obj.datasets || []).slice(0, -1);
  $('#dataInput').value = JSON.stringify(obj, null, 2);
}

// Boot
function boot() {
  setChartType('line');
  $('#legendPos').value = 'top';
  $('#palette').value = 'classic';
  $('#dataInput').value = JSON.stringify({
    labels: ['Jan','Feb','Mar','Apr','May','Jun','Jul'],
    datasets: [
      { label: 'Revenue', data: [12, 19, 13, 25, 18, 22, 30] },
      { label: 'Cost', data: [8, 11, 9, 12, 10, 13, 15] }
    ]
  }, null, 2);
  initUI();
  scheduleRender();
}

// Guard: destroy chart when unloading to free memory
window.addEventListener('beforeunload', () => {
  ChartManager.destroy();
});

// Start
boot();


</script>
</body>
</html>
