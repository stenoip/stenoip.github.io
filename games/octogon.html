<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Octogon Match</title>
<script>
// The function gets called when the window is fully loaded
window.onload = function() {
    // Get the canvas and context
    var canvas = document.getElementById("viewport");
    var context = canvas.getContext("2d");

    // Audio Elements
    var bgMusic = document.getElementById("bg-music");
    var swapSound = new Audio("https://stenoip.github.io/games/octogon-assets/whistle-slide-down-02-350715.mp3");
    var matchSound = new Audio("https://stenoip.github.io/games/octogon-assets/large-break-363165.mp3");
    var levelUpSound = new Audio("https://stenoip.github.io/games/octogon-assets/level_up_sfx.mp3");
    var gameOverSound = new Audio("https://stenoip.github.io/games/octogon-assets/game-over-31-179699.mp3");

    // Load and play music from localStorage
    if (localStorage.getItem('musicTime')) {
        bgMusic.currentTime = localStorage.getItem('musicTime');
    }
    bgMusic.play().catch(e => console.log("Music play blocked: ", e));

    // Save music time before reload/close
    window.addEventListener('beforeunload', () => {
        localStorage.setItem('musicTime', bgMusic.currentTime);
    });

    // Play a sound effect
    function playSound(sound) {
        sound.currentTime = 0;
        sound.play().catch(e => console.log("Sound effect blocked: ", e));
    }

    // Timing and frames per second
    var lastframe = 0;
    var fpstime = 0;
    var framecount = 0;
    var fps = 0;

    // Mouse dragging
    var drag = false;

    // Level object
    var level = {
        x: 250,      // X position
        y: 113,      // Y position
        columns: 8,  // Number of tile columns
        rows: 8,     // Number of tile rows
        tilewidth: 40, // Visual width of a tile
        tileheight: 40, // Visual height of a tile
        tiles: [],   // The two-dimensional tile array
        selectedtile: { selected: false, column: 0, row: 0 }
    };

   /*This is where you add
   
   LEVELS!
   */
  var levels = [
        { moves: 30, scoreTarget: 1000 },
        { moves: 25, scoreTarget: 1500 },
        { moves: 20, scoreTarget: 2500 },
     
    ];
    var currentLevel = 0;
    var movesRemaining = levels[currentLevel].moves;
    var score = 0;
    var gameOver = false;
    var levelComplete = false;

    // Tile types
    var TILE_TYPE = {
        NORMAL: 0,
        BOMB: 10,
        STRIPED_H: 11,
        STRIPED_V: 12,
        COLOR_BOMB: 13,
        EMPTY: -1
    };
    
    // All of the different tile colors in RGB
    var tilecolors = [
        [255, 128, 128], // Red
        [128, 255, 128], // Green
        [128, 128, 255], // Blue
        [255, 255, 128], // Yellow
        [255, 128, 255], // Magenta
        [128, 255, 255]  // Cyan
    ];
    
    // Clusters and moves that were found
    var clusters = [];  // { column, row, length, horizontal }
    var moves = [];     // { column1, row1, column2, row2 }
    
    // Current move
    var currentmove = { column1: 0, row1: 0, column2: 0, row2: 0 };
    
    // Game states
    var gamestates = { init: 0, ready: 1, resolve: 2 };
    var gamestate = gamestates.init;
    
    // Animation variables
    var animationstate = 0;
    var animationtime = 0;
    var animationtimetotal = 0.3;
    
    // Show available moves
    var showmoves = false;
    
    // The AI bot
    var aibot = false;

    // Gui buttons
   var buttons = [
        { x: 30, y: 330, width: 150, height: 50, text: "New Game" },
        { x: 30, y: 380, width: 150, height: 50, text: "Show Moves" },
        
    ];

    // Initialize the game
    function init() {
        // Add mouse events
        canvas.addEventListener("mousemove", onMouseMove);
        canvas.addEventListener("mousedown", onMouseDown);
        canvas.addEventListener("mouseup", onMouseUp);
        canvas.addEventListener("mouseout", onMouseOut);

        // Initialize the two-dimensional tile array
        for (var i = 0; i < level.columns; i++) {
            level.tiles[i] = [];
            for (var j = 0; j < level.rows; j++) {
                // Define a tile type and a shift parameter for animation
                level.tiles[i][j] = { type: 0, shift: 0, special: null };
            }
        }

        // New game
        newGame();

        // Enter main loop
        main(0);
    }

    // Main loop
    function main(tframe) {
        // Request animation frames
        window.requestAnimationFrame(main);

        // Update and render the game
        update(tframe);
        render();
    }

    // Update the game state
    function update(tframe) {
        var dt = (tframe - lastframe) / 1000;
        lastframe = tframe;

        // Update the fps counter
        updateFps(dt);

        if (gamestate == gamestates.ready) {
            // Check for game over
            if (movesRemaining <= 0 && !levelComplete) {
                findMoves();
                if (moves.length === 0) {
                    gameOver = true;
                    playSound(gameOverSound);
                }
            } else if (score >= levels[currentLevel].scoreTarget && !levelComplete) {
                levelComplete = true;
                playSound(levelUpSound);
            }

            // Let the AI bot make a move, if enabled
            if (aibot) {
                animationtime += dt;
                if (animationtime > animationtimetotal) {
                    findMoves();
                    if (moves.length > 0) {
                        var move = moves[Math.floor(Math.random() * moves.length)];
                        mouseSwap(move.column1, move.row1, move.column2, move.row2);
                    }
                    animationtime = 0;
                }
            }
        } else if (gamestate == gamestates.resolve) {
            animationtime += dt;

            if (animationstate == 0) {
                // Remove clusters and add new tiles
                if (animationtime > animationtimetotal) {
                    findClusters();
                    if (clusters.length > 0) {
                        for (var i = 0; i < clusters.length; i++) {
                            score += 100 * (clusters[i].length - 2);
                        }
                        removeClusters();
                        playSound(matchSound);
                        animationstate = 1;
                    } else {
                        gamestate = gamestates.ready;
                    }
                    animationtime = 0;
                }
            } else if (animationstate == 1) {
                // Shift tiles
                if (animationtime > animationtimetotal) {
                    shiftTiles();
                    animationstate = 0;
                    animationtime = 0;
                    findClusters();
                    if (clusters.length <= 0) {
                        gamestate = gamestates.ready;
                    }
                }
            } else if (animationstate == 2) {
                // Swapping tiles animation
                if (animationtime > animationtimetotal) {
                    swap(currentmove.column1, currentmove.row1, currentmove.column2, currentmove.row2);
                    findClusters();
                    if (clusters.length > 0) {
                        playSound(swapSound);
                        animationstate = 0;
                        animationtime = 0;
                        gamestate = gamestates.resolve;
                        movesRemaining--;
                    } else {
                        animationstate = 3;
                        animationtime = 0;
                    }
                    findMoves();
                    findClusters();
                }
            } else if (animationstate == 3) {
                // Rewind swapping animation
                if (animationtime > animationtimetotal) {
                    swap(currentmove.column1, currentmove.row1, currentmove.column2, currentmove.row2);
                    gamestate = gamestates.ready;
                }
            }
        }
    }

    function updateFps(dt) {
        if (fpstime > 0.25) {
            fps = Math.round(framecount / fpstime);
            fpstime = 0;
            framecount = 0;
        }
        fpstime += dt;
        framecount++;
    }

    function drawCenterText(text, x, y, width) {
        var textdim = context.measureText(text);
        context.fillText(text, x + (width - textdim.width) / 2, y);
    }

    function render() {
        drawFrame();
        
        context.fillStyle = "#000000";
        context.font = "24px Verdana";
        drawCenterText("Score:", 30, level.y + 40, 150);
        drawCenterText(score, 30, level.y + 70, 150);
        drawCenterText("Moves:", 30, level.y + 110, 150);
        drawCenterText(movesRemaining, 30, level.y + 140, 150);
        drawCenterText("Target:", 30, level.y + 180, 150);
        drawCenterText(levels[currentLevel].scoreTarget, 30, level.y + 210, 150);

        drawButtons();

        var levelwidth = level.columns * level.tilewidth;
        var levelheight = level.rows * level.tileheight;
        context.fillStyle = "#000000";
        context.fillRect(level.x - 4, level.y - 4, levelwidth + 8, levelheight + 8);
        
        renderTiles();
        renderClusters();

        if (showmoves && clusters.length <= 0 && gamestate == gamestates.ready) {
            renderMoves();
        }

        if (gameOver) {
            context.fillStyle = "rgba(0, 0, 0, 0.8)";
            context.fillRect(level.x, level.y, levelwidth, levelheight);
            context.fillStyle = "#ffffff";
            context.font = "24px Verdana";
            drawCenterText("Game Over!", level.x, level.y + levelheight / 2 + 10, levelwidth);
        } else if (levelComplete) {
            context.fillStyle = "rgba(0, 0, 0, 0.8)";
            context.fillRect(level.x, level.y, levelwidth, levelheight);
            context.fillStyle = "#ffffff";
            context.font = "24px Verdana";
            drawCenterText("Level Complete!", level.x, level.y + levelheight / 2, levelwidth);
            drawCenterText("Press 'New Game' to continue", level.x, level.y + levelheight / 2 + 30, levelwidth);
        }
    }

    function drawFrame() {
        context.fillStyle = "#19e6b9";
        context.fillRect(0, 0, canvas.width, canvas.height);
        context.fillStyle = "#466880";
        context.fillRect(1, 1, canvas.width - 2, canvas.height - 2);

        context.fillStyle = "#19e6b9";
        context.fillRect(0, 0, canvas.width, 65);

        context.fillStyle = "#ffffff";
        context.font = "24px Verdana";
        context.fillText("Octogon Match 2025", 10, 25);

        context.fillStyle = "#ffffff";
        context.font = "12px Verdana";
        context.fillText("By Stenoip Company", 13, 40);
        context.fillText("Fps: " + fps, 13, 50);
    }

    function drawButtons() {
        for (var i = 0; i < buttons.length; i++) {
            context.fillStyle = "#000000";
            context.fillRect(buttons[i].x, buttons[i].y, buttons[i].width, buttons[i].height);

            context.fillStyle = "#ffffff";
            context.font = "18px Verdana";
            var textdim = context.measureText(buttons[i].text);
            context.fillText(buttons[i].text, buttons[i].x + (buttons[i].width - textdim.width) / 2, buttons[i].y + 30);
        }
    }

    function renderTiles() {
        for (var i = 0; i < level.columns; i++) {
            for (var j = 0; j < level.rows; j++) {
                var shift = level.tiles[i][j].shift;
                var coord = getTileCoordinate(i, j, 0, (animationtime / animationtimetotal) * shift);
                
                if (level.tiles[i][j].type !== TILE_TYPE.EMPTY) {
                    let tile = level.tiles[i][j];
                    let color = tilecolors[tile.type];
                    
                    if (tile.special === TILE_TYPE.BOMB) {
                        drawBomb(coord.tilex, coord.tiley, level.tilewidth, level.tileheight);
                    } else if (tile.special === TILE_TYPE.STRIPED_H) {
                        drawStripedTile(coord.tilex, coord.tiley, level.tilewidth, level.tileheight, color, true);
                    } else if (tile.special === TILE_TYPE.STRIPED_V) {
                        drawStripedTile(coord.tilex, coord.tiley, level.tilewidth, level.tileheight, color, false);
                    } else if (tile.special === TILE_TYPE.COLOR_BOMB) {
                        drawColorBomb(coord.tilex, coord.tiley, level.tilewidth, level.tileheight);
                    } else {
                        drawTile(coord.tilex, coord.tiley, color[0], color[1], color[2]);
                    }
                }
                
                if (level.selectedtile.selected) {
                    if (level.selectedtile.column == i && level.selectedtile.row == j) {
                        drawTile(coord.tilex, coord.tiley, 255, 0, 0);
                    }
                }
            }
        }
        
        if (gamestate == gamestates.resolve && (animationstate == 2 || animationstate == 3)) {
            var shiftx = currentmove.column2 - currentmove.column1;
            var shifty = currentmove.row2 - currentmove.row1;
            var coord1 = getTileCoordinate(currentmove.column1, currentmove.row1, 0, 0);
            var coord1shift = getTileCoordinate(currentmove.column1, currentmove.row1, (animationtime / animationtimetotal) * shiftx, (animationtime / animationtimetotal) * shifty);
            var tile1 = level.tiles[currentmove.column1][currentmove.row1];
            var col1 = tilecolors[tile1.type];
            
            var coord2 = getTileCoordinate(currentmove.column2, currentmove.row2, 0, 0);
            var coord2shift = getTileCoordinate(currentmove.column2, currentmove.row2, (animationtime / animationtimetotal) * -shiftx, (animationtime / animationtimetotal) * -shifty);
            var tile2 = level.tiles[currentmove.column2][currentmove.row2];
            var col2 = tilecolors[tile2.type];
            
            drawTile(coord1.tilex, coord1.tiley, 0, 0, 0);
            drawTile(coord2.tilex, coord2.tiley, 0, 0, 0);
            
            if (animationstate == 2) {
                if (tile1.special === TILE_TYPE.BOMB) drawBomb(coord1shift.tilex, coord1shift.tiley, level.tilewidth, level.tileheight);
                else if (tile1.special === TILE_TYPE.STRIPED_H) drawStripedTile(coord1shift.tilex, coord1shift.tiley, level.tilewidth, level.tileheight, col1, true);
                else if (tile1.special === TILE_TYPE.STRIPED_V) drawStripedTile(coord1shift.tilex, coord1shift.tiley, level.tilewidth, level.tileheight, col1, false);
                else if (tile1.special === TILE_TYPE.COLOR_BOMB) drawColorBomb(coord1shift.tilex, coord1shift.tiley, level.tilewidth, level.tileheight);
                else drawTile(coord1shift.tilex, coord1shift.tiley, col1[0], col1[1], col1[2]);
                
                if (tile2.special === TILE_TYPE.BOMB) drawBomb(coord2shift.tilex, coord2shift.tiley, level.tilewidth, level.tileheight);
                else if (tile2.special === TILE_TYPE.STRIPED_H) drawStripedTile(coord2shift.tilex, coord2shift.tiley, level.tilewidth, level.tileheight, col2, true);
                else if (tile2.special === TILE_TYPE.STRIPED_V) drawStripedTile(coord2shift.tilex, coord2shift.tiley, level.tilewidth, level.tileheight, col2, false);
                else if (tile2.special === TILE_TYPE.COLOR_BOMB) drawColorBomb(coord2shift.tilex, coord2shift.tiley, level.tilewidth, level.tileheight);
                else drawTile(coord2shift.tilex, coord2shift.tiley, col2[0], col2[1], col2[2]);
            } else {
                 if (tile2.special === TILE_TYPE.BOMB) drawBomb(coord2shift.tilex, coord2shift.tiley, level.tilewidth, level.tileheight);
                else if (tile2.special === TILE_TYPE.STRIPED_H) drawStripedTile(coord2shift.tilex, coord2shift.tiley, level.tilewidth, level.tileheight, col2, true);
                else if (tile2.special === TILE_TYPE.STRIPED_V) drawStripedTile(coord2shift.tilex, coord2shift.tiley, level.tilewidth, level.tileheight, col2, false);
                else if (tile2.special === TILE_TYPE.COLOR_BOMB) drawColorBomb(coord2shift.tilex, coord2shift.tiley, level.tilewidth, level.tileheight);
                else drawTile(coord2shift.tilex, coord2shift.tiley, col2[0], col2[1], col2[2]);
                
                if (tile1.special === TILE_TYPE.BOMB) drawBomb(coord1shift.tilex, coord1shift.tiley, level.tilewidth, level.tileheight);
                else if (tile1.special === TILE_TYPE.STRIPED_H) drawStripedTile(coord1shift.tilex, coord1shift.tiley, level.tilewidth, level.tileheight, col1, true);
                else if (tile1.special === TILE_TYPE.STRIPED_V) drawStripedTile(coord1shift.tilex, coord1shift.tiley, level.tilewidth, level.tileheight, col1, false);
                else if (tile1.special === TILE_TYPE.COLOR_BOMB) drawColorBomb(coord1shift.tilex, coord1shift.tiley, level.tilewidth, level.tileheight);
                else drawTile(coord1shift.tilex, coord1shift.tiley, col1[0], col1[1], col1[2]);
            }
        }
    }

    function getTileCoordinate(column, row, columnoffset, rowoffset) {
        var tilex = level.x + (column + columnoffset) * level.tilewidth;
        var tiley = level.y + (row + rowoffset) * level.tileheight;
        return { tilex: tilex, tiley: tiley };
    }

    function drawOctagon(x, y, size, r, g, b) {
        var sideLength = size * 0.4;
        var innerOffset = size * 0.3;
        context.fillStyle = "rgb(" + r + "," + g + "," + b + ")";
        context.beginPath();
        context.moveTo(x + innerOffset, y);
        context.lineTo(x + size - innerOffset, y);
        context.lineTo(x + size, y + innerOffset);
        context.lineTo(x + size, y + size - innerOffset);
        context.lineTo(x + size - innerOffset, y + size);
        context.lineTo(x + innerOffset, y + size);
        context.lineTo(x, y + size - innerOffset);
        context.lineTo(x, y + innerOffset);
        context.closePath();
        context.fill();
        context.lineWidth = 2;
        context.strokeStyle = "#000000";
        context.stroke();
    }
    
    function drawTile(x, y, r, g, b) {
        drawOctagon(x + 2, y + 2, level.tilewidth - 4, r, g, b);
    }
    
    function drawBomb(x, y, width, height) {
        // Brown-red gradient octagon
        var gradient = context.createLinearGradient(x, y, x + width, y + height);
        gradient.addColorStop(0, '#A52A2A');
        gradient.addColorStop(1, '#FF4500');
        
        var sideLength = width * 0.4;
        var innerOffset = width * 0.3;
        context.fillStyle = gradient;
        context.beginPath();
        context.moveTo(x + innerOffset, y);
        context.lineTo(x + width - innerOffset, y);
        context.lineTo(x + width, y + innerOffset);
        context.lineTo(x + width, y + height - innerOffset);
        context.lineTo(x + width - innerOffset, y + height);
        context.lineTo(x + innerOffset, y + height);
        context.lineTo(x, y + height - innerOffset);
        context.lineTo(x, y + innerOffset);
        context.closePath();
        context.fill();
        context.lineWidth = 2;
        context.strokeStyle = "#000000";
        context.stroke();
    }
    
    function drawStripedTile(x, y, width, height, color, isHorizontal) {
        drawTile(x, y, color[0], color[1], color[2]);
        context.fillStyle = "rgba(0,0,0,0.5)";
        if (isHorizontal) {
            context.fillRect(x + 5, y + height / 2 - 2, width - 10, 4);
        } else {
            context.fillRect(x + width / 2 - 2, y + 5, 4, height - 10);
        }
    }
    
    function drawColorBomb(x, y, width, height) {
        var gradient = context.createRadialGradient(x + width / 2, y + height / 2, 5, x + width / 2, y + height / 2, width / 2);
        gradient.addColorStop(0, '#FFD700'); // Gold
        gradient.addColorStop(1, '#B8860B'); // DarkGoldenRod
        
        var sideLength = width * 0.4;
        var innerOffset = width * 0.3;
        context.fillStyle = gradient;
        context.beginPath();
        context.moveTo(x + innerOffset, y);
        context.lineTo(x + width - innerOffset, y);
        context.lineTo(x + width, y + innerOffset);
        context.lineTo(x + width, y + height - innerOffset);
        context.lineTo(x + width - innerOffset, y + height);
        context.lineTo(x + innerOffset, y + height);
        context.lineTo(x, y + height - innerOffset);
        context.lineTo(x, y + innerOffset);
        context.closePath();
        context.fill();
        context.lineWidth = 2;
        context.strokeStyle = "#000000";
        context.stroke();
        
        // Add a highlight for 3D effect
        context.beginPath();
        context.moveTo(x + width * 0.3, y + height * 0.3);
        context.lineTo(x + width * 0.7, y + height * 0.3);
        context.lineTo(x + width * 0.5, y + height * 0.5);
        context.closePath();
        context.fillStyle = "rgba(255,255,255,0.7)";
        context.fill();
    }

    function renderClusters() {
        for (var i = 0; i < clusters.length; i++) {
            var coord = getTileCoordinate(clusters[i].column, clusters[i].row, 0, 0);

            if (clusters[i].horizontal) {
                context.fillStyle = "#00ff00";
                context.fillRect(coord.tilex + level.tilewidth / 2, coord.tiley + level.tileheight / 2 - 4, (clusters[i].length - 1) * level.tilewidth, 8);
            } else {
                context.fillStyle = "#0000ff";
                context.fillRect(coord.tilex + level.tilewidth / 2 - 4, coord.tiley + level.tileheight / 2, 8, (clusters[i].length - 1) * level.tileheight);
            }
        }
    }

    function renderMoves() {
        for (var i = 0; i < moves.length; i++) {
            var coord1 = getTileCoordinate(moves[i].column1, moves[i].row1, 0, 0);
            var coord2 = getTileCoordinate(moves[i].column2, moves[i].row2, 0, 0);

            context.strokeStyle = "#ff0000";
            context.beginPath();
            context.moveTo(coord1.tilex + level.tilewidth / 2, coord1.tiley + level.tileheight / 2);
            context.lineTo(coord2.tilex + level.tilewidth / 2, coord2.tiley + level.tileheight / 2);
            context.stroke();
        }
    }

    function newGame() {
        score = 0;
        currentLevel = 0;
        movesRemaining = levels[currentLevel].moves;
        gamestate = gamestates.ready;
        gameOver = false;
        levelComplete = false;
        createLevel();
        findMoves();
        findClusters();
    }

    function createLevel() {
        let done = false;
        while (!done) {
            for (let i = 0; i < level.columns; i++) {
                for (let j = 0; j < level.rows; j++) {
                    level.tiles[i][j].type = getRandomTile();
                    level.tiles[i][j].special = TILE_TYPE.NORMAL;
                }
            }
            resolveClusters();
            findMoves();
            if (moves.length > 0) {
                done = true;
            }
        }
    }

    function getRandomTile() {
        return Math.floor(Math.random() * tilecolors.length);
    }
    
    function resolveClusters() {
        findClusters();
        while (clusters.length > 0) {
            removeClusters();
            shiftTiles();
            findClusters();
        }
    }
    
    function findClusters() {
        clusters = [];
        for (var j = 0; j < level.rows; j++) {
            var matchlength = 1;
            for (var i = 0; i < level.columns; i++) {
                var checkcluster = false;
                if (i == level.columns - 1) {
                    checkcluster = true;
                } else {
                    if (level.tiles[i][j].type === level.tiles[i + 1][j].type && level.tiles[i][j].type !== TILE_TYPE.EMPTY) {
                        matchlength += 1;
                    } else {
                        checkcluster = true;
                    }
                }
                if (checkcluster) {
                    if (matchlength >= 3) {
                        // Check for T or L shapes for Bomb
                        if (matchlength === 5) {
                            level.tiles[i + 1 - matchlength][j].special = TILE_TYPE.COLOR_BOMB;
                        } else if (matchlength === 4) {
                            level.tiles[i + 1 - matchlength][j].special = TILE_TYPE.STRIPED_H;
                        } else if (matchlength === 3) {
                            // Check for L/T shape here
                            let isLorT = false;
                            // Check for vertical extension
                            if (j > 0 && j < level.rows - 1) {
                                if (level.tiles[i][j-1].type === level.tiles[i+1-matchlength][j].type && level.tiles[i][j+1].type === level.tiles[i+1-matchlength][j].type) {
                                    isLorT = true;
                                }
                            }
                            if (isLorT) {
                                level.tiles[i + 1 - matchlength][j].special = TILE_TYPE.BOMB;
                            }
                        }
                        
                        clusters.push({ column: i + 1 - matchlength, row: j, length: matchlength, horizontal: true });
                    }
                    matchlength = 1;
                }
            }
        }

        // Find vertical clusters
        for (var i = 0; i < level.columns; i++) {
            var matchlength = 1;
            for (var j = 0; j < level.rows; j++) {
                var checkcluster = false;
                if (j == level.rows - 1) {
                    checkcluster = true;
                } else {
                    if (level.tiles[i][j].type === level.tiles[i][j + 1].type && level.tiles[i][j].type !== TILE_TYPE.EMPTY) {
                        matchlength += 1;
                    } else {
                        checkcluster = true;
                    }
                }
                if (checkcluster) {
                    if (matchlength >= 3) {
                        if (matchlength === 5) {
                            level.tiles[i][j + 1 - matchlength].special = TILE_TYPE.COLOR_BOMB;
                        } else if (matchlength === 4) {
                            level.tiles[i][j + 1 - matchlength].special = TILE_TYPE.STRIPED_V;
                        } else if (matchlength === 3) {
                            // Check for L/T shape here
                            let isLorT = false;
                            // Check for horizontal extension
                            if (i > 0 && i < level.columns - 1) {
                                if (level.tiles[i-1][j].type === level.tiles[i][j+1-matchlength].type && level.tiles[i+1][j].type === level.tiles[i][j+1-matchlength].type) {
                                    isLorT = true;
                                }
                            }
                            if (isLorT) {
                                level.tiles[i][j+1-matchlength].special = TILE_TYPE.BOMB;
                            }
                        }
                        clusters.push({ column: i, row: j + 1 - matchlength, length: matchlength, horizontal: false });
                    }
                    matchlength = 1;
                }
            }
        }
    }

    function findMoves() {
        moves = [];
        for (var j = 0; j < level.rows; j++) {
            for (var i = 0; i < level.columns - 1; i++) {
                swap(i, j, i + 1, j);
                findClusters();
                swap(i, j, i + 1, j);
                if (clusters.length > 0) {
                    moves.push({ column1: i, row1: j, column2: i + 1, row2: j });
                }
            }
        }

        for (var i = 0; i < level.columns; i++) {
            for (var j = 0; j < level.rows - 1; j++) {
                swap(i, j, i, j + 1);
                findClusters();
                swap(i, j, i, j + 1);
                if (clusters.length > 0) {
                    moves.push({ column1: i, row1: j, column2: i, row2: j + 1 });
                }
            }
        }
        clusters = [];
    }

    function loopClusters(func) {
        for (var i = 0; i < clusters.length; i++) {
            var cluster = clusters[i];
            var coffset = 0;
            var roffset = 0;
            for (var j = 0; j < cluster.length; j++) {
                func(i, cluster.column + coffset, cluster.row + roffset, cluster);
                if (cluster.horizontal) {
                    coffset++;
                } else {
                    roffset++;
                }
            }
        }
    }

    function removeClusters() {
        let tilesToRemove = new Set();
        
        loopClusters(function(index, column, row, cluster) {
            let tile = level.tiles[column][row];
            if (tile.special === TILE_TYPE.BOMB) {
                for (let c = column - 1; c <= column + 1; c++) {
                    for (let r = row - 1; r <= row + 1; r++) {
                        if (c >= 0 && c < level.columns && r >= 0 && r < level.rows) {
                            tilesToRemove.add(`${c},${r}`);
                        }
                    }
                }
            } else if (tile.special === TILE_TYPE.STRIPED_H) {
                for (let c = 0; c < level.columns; c++) {
                    tilesToRemove.add(`${c},${row}`);
                }
            } else if (tile.special === TILE_TYPE.STRIPED_V) {
                for (let r = 0; r < level.rows; r++) {
                    tilesToRemove.add(`${column},${r}`);
                }
            } else if (tile.special === TILE_TYPE.COLOR_BOMB) {
                let colorToRemove = tile.type;
                for (let c = 0; c < level.columns; c++) {
                    for (let r = 0; r < level.rows; r++) {
                        if (level.tiles[c][r].type === colorToRemove) {
                            tilesToRemove.add(`${c},${r}`);
                        }
                    }
                }
            } else {
                tilesToRemove.add(`${column},${row}`);
            }
        });

        tilesToRemove.forEach(pos => {
            let [c, r] = pos.split(',').map(Number);
            level.tiles[c][r].type = TILE_TYPE.EMPTY;
            level.tiles[c][r].special = null;
        });

        for (var i = 0; i < level.columns; i++) {
            var shift = 0;
            for (var j = level.rows - 1; j >= 0; j--) {
                if (level.tiles[i][j].type === TILE_TYPE.EMPTY) {
                    shift++;
                    level.tiles[i][j].shift = 0;
                } else {
                    level.tiles[i][j].shift = shift;
                }
            }
        }
    }

    function shiftTiles() {
        for (var i = 0; i < level.columns; i++) {
            for (var j = level.rows - 1; j >= 0; j--) {
                if (level.tiles[i][j].type === TILE_TYPE.EMPTY) {
                    level.tiles[i][j].type = getRandomTile();
                } else {
                    var shift = level.tiles[i][j].shift;
                    if (shift > 0) {
                        swap(i, j, i, j + shift);
                    }
                }
                level.tiles[i][j].shift = 0;
            }
        }
    }
    
    function getMouseTile(pos) {
        var tx = Math.floor((pos.x - level.x) / level.tilewidth);
        var ty = Math.floor((pos.y - level.y) / level.tileheight);

        if (tx >= 0 && tx < level.columns && ty >= 0 && ty < level.rows) {
            return {
                valid: true,
                x: tx,
                y: ty
            };
        }
        return {
            valid: false,
            x: 0,
            y: 0
        };
    }

    function canSwap(x1, y1, x2, y2) {
        if ((Math.abs(x1 - x2) == 1 && y1 == y2) || (Math.abs(y1 - y2) == 1 && x1 == x2)) {
            return true;
        }
        return false;
    }

    function swap(x1, y1, x2, y2) {
        var typeswap = level.tiles[x1][y1].type;
        level.tiles[x1][y1].type = level.tiles[x2][y2].type;
        level.tiles[x2][y2].type = typeswap;
        
        var specialsSwap = level.tiles[x1][y1].special;
        level.tiles[x1][y1].special = level.tiles[x2][y2].special;
        level.tiles[x2][y2].special = specialsSwap;
    }

    function mouseSwap(c1, r1, c2, r2) {
        if (gamestate === gamestates.ready && !gameOver && !levelComplete) {
            currentmove = { column1: c1, row1: r1, column2: c2, row2: r2 };
            level.selectedtile.selected = false;
            animationstate = 2;
            animationtime = 0;
            gamestate = gamestates.resolve;
        }
    }

    function onMouseMove(e) {
        var pos = getMousePos(canvas, e);
        if (drag && level.selectedtile.selected) {
            mt = getMouseTile(pos);
            if (mt.valid) {
                if (canSwap(mt.x, mt.y, level.selectedtile.column, level.selectedtile.row)) {
                    mouseSwap(mt.x, mt.y, level.selectedtile.column, level.selectedtile.row);
                }
            }
        }
    }

    function onMouseDown(e) {
        var pos = getMousePos(canvas, e);
        if (!drag) {
            mt = getMouseTile(pos);
            if (mt.valid) {
                var swapped = false;
                if (level.selectedtile.selected) {
                    if (mt.x == level.selectedtile.column && mt.y == level.selectedtile.row) {
                        level.selectedtile.selected = false;
                        drag = true;
                        return;
                    } else if (canSwap(mt.x, mt.y, level.selectedtile.column, level.selectedtile.row)) {
                        mouseSwap(mt.x, mt.y, level.selectedtile.column, level.selectedtile.row);
                        swapped = true;
                    }
                }
                if (!swapped) {
                    level.selectedtile.column = mt.x;
                    level.selectedtile.row = mt.y;
                    level.selectedtile.selected = true;
                }
            } else {
                level.selectedtile.selected = false;
            }
            drag = true;
        }

        for (var i = 0; i < buttons.length; i++) {
            if (pos.x >= buttons[i].x && pos.x < buttons[i].x + buttons[i].width && pos.y >= buttons[i].y && pos.y < buttons[i].y + buttons[i].height) {
                if (i == 0) {
                    if (levelComplete) {
                        currentLevel++;
                        if (currentLevel >= levels.length) {
                            alert("Congratulations! You've completed all levels.");
                            currentLevel = 0;
                        }
                        movesRemaining = levels[currentLevel].moves;
                        score = 0;
                        levelComplete = false;
                        createLevel();
                    } else {
                        newGame();
                    }
                } else if (i == 1) {
                    showmoves = !showmoves;
                    buttons[i].text = (showmoves ? "Hide" : "Show") + " Moves";
                } else if (i == 2) {
                    aibot = !aibot;
                    buttons[i].text = (aibot ? "Disable" : "Enable") + " AI Bot";
                }
            }
        }
    }

    function onMouseUp(e) {
        drag = false;
    }

    function onMouseOut(e) {
        drag = false;
    }

    function getMousePos(canvas, e) {
        var rect = canvas.getBoundingClientRect();
        return {
            x: Math.round((e.clientX - rect.left) / (rect.right - rect.left) * canvas.width),
            y: Math.round((e.clientY - rect.top) / (rect.bottom - rect.top) * canvas.height)
        };
    }

    init();
};
</script>
</head>
<body>
<canvas id="viewport" width="640" height="480"></canvas>
<audio id="bg-music" src="https://stenoip.github.io/games/calming-shapes-125459.mp3" loop></audio>
</body>
</html>
