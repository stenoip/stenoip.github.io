<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Trein Krús</title>
  <style>
    html, body {
      margin: 0;
      height: 100%;
      overflow: hidden;
      background: #87CEEB; /* blue sky */
      touch-action: none;  /* disable browser scroll gestures */
    }
    #hud {
      position: fixed; top: 10px; left: 10px; color: #fff; font: 14px monospace;
      background: rgba(0,0,0,0.4); padding: 6px 10px; border-radius: 6px;
      z-index: 10;
    }
    #overlay {
      position: fixed; top: 0; left: 0; width: 100%; height: 100%;
      background: rgba(0,0,0,0.7); color: #fff; display: none;
      flex-direction: column; align-items: center; justify-content: center;
      font-family: monospace; font-size: 24px; z-index: 20;
    }
    #overlay small { margin-top: 20px; font-size: 14px; color: #ccc; }
  </style>
</head>
<body>
  <div id="hud">Score: <b id="score">0</b> | Hi: <b id="hiscore">0</b></div>
  <div id="overlay">
    <div id="gameover-text">GAME OVER</div>
    <div id="final-score"></div>
    <small>© 2025 Stenoip Company</small>
    <div style="margin-top:20px;font-size:16px;">Press any key or tap to restart</div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>
  <script>
  // Globals (var-only as requested)
  var scene, camera, renderer, frog;
  var rows = [], nextZ = 0, score = 0, hi = 0, playing = true;
  var scoreEl = document.getElementById("score"), hiEl = document.getElementById("hiscore");
  var overlay = document.getElementById("overlay"), finalScore = document.getElementById("final-score");

  init();
  animate();

  function init(){
    scene = new THREE.Scene();
    camera = new THREE.PerspectiveCamera(60, innerWidth / innerHeight, 0.1, 1000);

    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(innerWidth, innerHeight);
    document.body.appendChild(renderer.domElement);

    // Lights
    var ambient = new THREE.AmbientLight(0xffffff, 0.7); scene.add(ambient);
    var dir = new THREE.DirectionalLight(0xffffff, 0.9); dir.position.set(10, 30, 20); scene.add(dir);

    // Horizon ground plane (very wide to fill left-right)
    var ground = new THREE.Mesh(
      new THREE.PlaneGeometry(4000, 4000),
      new THREE.MeshLambertMaterial({ color: 0x228B22 })
    );
    ground.rotation.x = -Math.PI / 2;
    scene.add(ground);

    // Frog
    var texLoader = new THREE.TextureLoader();
    var frogTex = texLoader.load("frog.png");
    frog = new THREE.Sprite(new THREE.SpriteMaterial({ map: frogTex, transparent: true }));
    frog.scale.set(1.6, 1.6, 1);
    frog.position.set(0, 0.8, 0);
    scene.add(frog);

    // Preload rows
    for (var i = 0; i < 20; i++) addRow(i < 5 ? "grass" : randType());

    // High score
    hi = parseInt(localStorage.getItem("tkHi") || "0"); hiEl.textContent = hi;

    // Controls
    document.addEventListener("keydown", handleKey);

    window.addEventListener("resize", function(){
      camera.aspect = innerWidth / innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight);
    });

    // Touch gestures (prevent scrolling)
    var touchStartX = 0, touchStartY = 0;
    document.addEventListener("touchstart", function(e){
      e.preventDefault();
      touchStartX = e.changedTouches[0].screenX;
      touchStartY = e.changedTouches[0].screenY;
    }, { passive: false });

    document.addEventListener("touchend", function(e){
      e.preventDefault();
      var dx = e.changedTouches[0].screenX - touchStartX;
      var dy = e.changedTouches[0].screenY - touchStartY;
      if (Math.abs(dx) > Math.abs(dy)) {
        if (dx > 30) moveFrog("right");
        else if (dx < -30) moveFrog("left");
      } else {
        if (dy > 30) moveFrog("down");
        else if (dy < -30) moveFrog("up");
      }
    }, { passive: false });

    // Tap/click to restart
    document.addEventListener("click", function(){
      if (!playing) restart();
    });
  }

  function randType(){ return ["grass","rail","river"][Math.floor(Math.random() * 3)]; }

  function addRow(type){
    var z = nextZ; nextZ -= 2;
    var row = { z: z, type: type, objects: [] };

    if (type === "grass"){
      // scatter trees
      for (var i = -8; i <= 8; i += 4){
        if (Math.random() < 0.3){
          var trunk = new THREE.Mesh(
            new THREE.CylinderGeometry(0.2, 0.2, 1),
            new THREE.MeshLambertMaterial({ color: 0x8B4513 })
          );
          trunk.position.set(i, 0.5, z); scene.add(trunk); row.objects.push(trunk);

          var leaves = new THREE.Mesh(
            new THREE.ConeGeometry(1, 2, 8),
            new THREE.MeshLambertMaterial({ color: 0x006400 })
          );
          leaves.position.set(i, 2, z); scene.add(leaves); row.objects.push(leaves);
        }
      }
    }

    if (type === "rail"){
      // Rail spanning horizon
      var rail = new THREE.Mesh(
        new THREE.BoxGeometry(4000, 0.2, 2),
        new THREE.MeshLambertMaterial({ color: 0x555555 })
      );
      rail.position.set(0, 0.1, z); scene.add(rail); row.objects.push(rail);

      // Train sprite
      var trainTex = new THREE.TextureLoader().load("train.png");
      var train = new THREE.Sprite(new THREE.SpriteMaterial({ map: trainTex, transparent: true }));
      train.scale.set(3.5, 1.6, 1);
      train.position.set(-2000, 0.8, z);
      train.userData = { speed: 0.15 + Math.random() * 0.1 };
      scene.add(train); row.objects.push(train);
    }

    if (type === "river"){
      // Water plane spanning horizon with animated texture
      var waterTex = new THREE.TextureLoader().load("https://threejs.org/examples/textures/waternormals.jpg");
      waterTex.wrapS = waterTex.wrapT = THREE.RepeatWrapping;
      waterTex.repeat.set(120, 1);

      var waterMat = new THREE.MeshPhongMaterial({
        map: waterTex,
        color: 0x00BFFF,
        transparent: true,
        opacity: 0.95,
        shininess: 80
      });

      var water = new THREE.Mesh(new THREE.BoxGeometry(4000, 0.1, 2), waterMat);
      water.position.set(0, 0.05, z);
      scene.add(water); row.objects.push(water);

      // Logs across horizon
      for (var i = 0; i < 40; i++){
        var log = new THREE.Mesh(
          new THREE.BoxGeometry(3, 0.5, 1),
          new THREE.MeshLambertMaterial({ color: 0x8B5A2B })
        );
        log.position.set(-1950 + i * 100, 0.5, z);
        log.userData = { speed: 0.05 + Math.random() * 0.05 };
        scene.add(log); row.objects.push(log);
      }
    }

    rows.push(row);
  }

  function moveFrog(dir){
    if (!playing){ restart(); return; }
    if (dir === "up"){ frog.position.z -= 2; score += 10; }
    if (dir === "down"){ frog.position.z += 2; }
    if (dir === "left"){ frog.position.x -= 2; }
    if (dir === "right"){ frog.position.x += 2; }
  }

  function handleKey(e){
    if (!playing){ restart(); return; }
    if (e.key === "ArrowUp") moveFrog("up");
    if (e.key === "ArrowDown") moveFrog("down");
    if (e.key === "ArrowLeft") moveFrog("left");
    if (e.key === "ArrowRight") moveFrog("right");
  }

  function animate(){
    requestAnimationFrame(animate);

    if (playing){
      for (var r = 0; r < rows.length; r++){
        var row = rows[r];

        if (row.type === "rail"){
          // find train sprite
          var train = null;
          for (var k = 0; k < row.objects.length; k++){
            if (row.objects[k].isSprite){ train = row.objects[k]; break; }
          }
          if (train){
            train.position.x += train.userData.speed;
            if (train.position.x > 2100) train.position.x = -2100;

            if (Math.abs(frog.position.z - row.z) < 1 && Math.abs(frog.position.x - train.position.x) < 2){
              gameOver();
            }
          }
        }

        if (row.type === "river"){
          var onLog = false;
          for (var j = 0; j < row.objects.length; j++){
            var obj = row.objects[j];

            // move logs
            if (obj.geometry && obj.geometry.parameters.width === 3){
              obj.position.x += obj.userData.speed;
              if (obj.position.x > 2100) obj.position.x = -2100;

              // frog rides log if overlapping
              if (Math.abs(frog.position.z - row.z) < 1 && Math.abs(frog.position.x - obj.position.x) < 2){
                onLog = true;
                frog.position.x += obj.userData.speed;
              }
            }

            // animate water texture flow
            if (obj.material && obj.material.map){
              obj.material.map.offset.x += 0.002;
            }
          }

          // fell into river
          if (Math.abs(frog.position.z - row.z) < 1 && !onLog){
            gameOver();
          }
        }
      }

      // camera follows frog
      camera.position.set(frog.position.x, 10, frog.position.z + 12);
      camera.lookAt(frog.position.x, 0, frog.position.z);

      // generate new rows as frog advances
      while (frog.position.z - 20 < nextZ){
        addRow(randType());
      }

      scoreEl.textContent = Math.floor(score);
    }

    renderer.render(scene, camera);
  }

  function gameOver(){
    playing = false;
    if (score > hi){
      hi = score;
      localStorage.setItem("tkHi", hi);
      hiEl.textContent = hi;
    }
    finalScore.textContent = "Score: " + Math.floor(score) + " | Hi: " + hi;
    overlay.style.display = "flex";
  }

  function restart(){
    overlay.style.display = "none";

    // Reset frog and score
    frog.position.set(0, 0.8, 0);
    score = 0;
    playing = true;

    // Clear rows and regenerate starting area
    for (var i = 0; i < rows.length; i++){
      var ro = rows[i];
      for (var j = 0; j < ro.objects.length; j++){
        scene.remove(ro.objects[j]);
      }
    }
    rows = [];
    nextZ = 0;
    for (var k = 0; k < 20; k++) addRow(k < 5 ? "grass" : randType());
  }
  </script>
</body>
</html>
